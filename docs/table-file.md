# Table File Design

## 1. Overview

The **Table File** is the fundamental physical persistence unit for a single table. It is designed to support **HTAP** workloads by combining efficient columnar scanning with fast random access for point lookups.

To ensure data consistency and recovery speed, the design strictly follows **Copy-on-Write (CoW)** and **Append-Only** principles. It integrates with the **No-Steal / No-Force** transactional model.

**Key Design Specifications:**
*   **Page Size:** Fixed at **64KB**.
*   **Indirection Architecture:** Separation of the **SuperPage** (Physical Anchor) and the **MetaPage** (Logical Snapshot) to allow non-blocking checkpoints.
*   **Atomicity:** Guaranteed via double-buffered SuperPages with Header-Footer validation.
*   **Decoupling:** Data Checkpoints (Tuple Mover) and Index Checkpoints operate independently.

## 2. Physical Layout

The file is divided into fixed-size 64KB pages. Page 0 is the fixed anchor; all other pages are dynamically allocated.

```text
+-------------------------------------------------------+
| Page 0: SuperPage (Double-Buffered Anchors A/B)       |
+-------------------------------------------------------+
| Page 1: MetaPage (Snapshot V100)                      | <--- Dynamic, CoW
+-------------------------------------------------------+
| Page 2: SpaceMap Page (Allocated/Free Bitmaps)        |
+-------------------------------------------------------+
| Page 3: LWC Data Block (RowID 0~N)                    |
+-------------------------------------------------------+
| Page 4: DiskTree Node (Index Internal/Leaf)           |
+-------------------------------------------------------+
| ...                                                   |
+-------------------------------------------------------+
| Page N: MetaPage (Snapshot V101)                      | <--- New version
+-------------------------------------------------------+
```

## 3. SuperPage Design (The Anchor)

The **SuperPage** (Page 0) acts as the static entry point to the file. It is lightweight and contains two slots for double-buffering. Each slot points to the latest valid **MetaPage**.

### 3.1. Structure of a Slot
| Section | Field | Description |
| :--- | :--- | :--- |
| **Header** | `magic_number` | File signature. |
| | `version` | File format version. |
| | `trx_id` | **Transaction ID** of the coordinator that wrote this slot. Used to identify the freshest anchor. |
| **Body** | **`meta_page_id`** | Pointer to the latest **MetaPage**. |
| **Footer** | `checksum` | CRC32C checksum of Header + Body. |
| | `trx_id_redundant` | Must match `Header.trx_id`. |

### 3.2. Atomic Update Protocol
To update the file state (commit a checkpoint):
1.  **Write**: Write Header (new `trx_id`), Body (new `meta_page_id`), and Footer to the inactive slot (A or B) within Page 0.
2.  **Fsync**: Persist Page 0 to disk.
3.  **Completion**: Once fsync returns successfully, the new state is valid. There is **no need** to check for active transactions during this step.

## 4. MetaPage Design (The Snapshot)

The **MetaPage** holds the complete state of the table at a specific point in time. It is a dynamic page managed via CoW. Every checkpoint creates a completely new MetaPage.

### 4.1. Structure
| Field | Description |
| :--- | :--- |
| `schema_info` | Column definitions, types, and compression metadata. |
| `block_index_root` | Root PageID of the **Block Index** (RowID -> LWC Block). |
| **`bitmap_tree_root`** | Root PageID of the **Bitmap B+Tree** for offloaded delete bitmaps. |
| `disktree_roots` | Map `<IndexID, PageID>` storing roots for all Secondary Indexes. |
| `space_map_root` | PageID of the **SpaceMap**. |
| `pivot_rowid` | The watermark separating Disk Store (<) and Memory Store (>=). |
| **`watermarks`** | A structure containing all component watermarks for recovery log truncation. |
| | &nbsp;&nbsp;**`heap_redo_start_cts`** | Redo log start point for the in-memory RowStore. |
| | &nbsp;&nbsp;**`delta_rec_cts`** | Persistence watermark for the on-disk delete bitmaps. |
| | &nbsp;&nbsp;**`index_rec_cts`** | Map `<IndexID, CTS>` of persistence watermarks for each index. |
| **`last_checkpoint_sts`** | The logical watermark (Start Timestamp) of the transaction that created this snapshot. Crucial for recovery filtering. |
| **`gc_page_list`** | A list of PageIDs that became obsolete in this version (including the *previous* MetaPage ID). |

### 4.2. Lifecycle
*   **Creation**: Generated by the Coordinator at the end of a Data, Delta, or Index Checkpoint.
*   **Obsolescence**: When a newer MetaPage is committed, the old MetaPage ID is added to the new MetaPage's `gc_page_list`.
*   **Reclamation**: When `MetaPage.last_checkpoint_sts` < `Global_Min_Active_STS`, the MetaPage **and** all pages in its `gc_page_list` can be reclaimed, as no active transaction can be viewing them.

## 5. Space Management & Garbage Collection

Space is managed via **SpaceMap Pages** (referenced by `MetaPage.space_map_root`).

### 5.1. Page States
1.  **Allocated**: In use by the current MetaPage or its children (Data, Index, Bitmaps).
2.  **GC_Wait**: Physically exists but logically obsolete. Referenced only by the `gc_page_list` of a MetaPage. Visible to long-running transactions holding that MetaPage.
3.  **Free**: Marked as free in the SpaceMap.

### 5.2. Non-Blocking GC Strategy
The Indirection Architecture solves the long transaction problem:

1.  **Scenario**: Transaction $T_{long}$ starts at logical time 100. It grabs the SuperPage, which points to `MetaPage_V1`.
2.  **Checkpoint**: A checkpoint runs at time 200. It creates `MetaPage_V2`.
    *   `MetaPage_V2.gc_page_list` includes `MetaPage_V1` and other old pages.
    *   SuperPage is updated to point to `MetaPage_V2`.
3.  **Result**:
    *   New transactions see `MetaPage_V2`.
    *   $T_{long}$ continues reading from `MetaPage_V1`.
    *   The background GC thread scans `MetaPage_V2`. It sees `MetaPage_V1` in the GC list. Since $T_{long}$ (Start Time 100) is still active, it **skips** recycling `MetaPage_V1`.
    *   Once $T_{long}$ commits, the next GC run will safely recycle `MetaPage_V1` and its children.

## 6. LWC Block Design (Data Storage)

LWC (LightWeight Columnar) blocks are stored in **PAX (Partition Attributes Across)** format within a 64KB page. They are optimized for both TP point lookups and AP scans.

### 6.1. Internal Structure

```text
[Block Header]
  - row_count
  - null_bitmap_offset
  - data_offsets[] (Start offset for each column)

[Null Bitmaps Area]
  - Column 1 NullBitmap (if nullable)
  - Column 2 NullBitmap ...
  - (Non-null columns occupy 0 bytes here)

[Data Area - Column 1]
  - Compression Metadata (Min/Max, Dict Base)
  - Payload (Compressed Data)

[Data Area - Column 2]
  ...
```

### 6.2. Compression Strategy

Algorithms are selected to ensure **O(1) random access** (or near O(1)) to support HTAP point queries without full block decompression.

1.  **Integers / Dates / Timestamps**:
    *   **Bitpacking (Frame of Reference)**: Store the `Min` value in metadata. Store deltas using the minimal number of bits required.
2.  **Strings (Low Cardinality)**:
    *   **Dictionary Encoding**: Store a local or global dictionary. Data payload consists of bitpacked integer IDs.
3.  **Strings (High Cardinality)**:
    *   **FSST (Fast Static Symbol Table)**: Allows random access to compressed strings and partial matching without full decompression.
4.  **Others (Default)**:
    *   **Flat**: Uncompressed storage to guarantee write/read performance.

## 7. Decoupled Checkpoint Workflows

Data persistence (Data Checkpoint), deletion persistence (Delta Checkpoint), and Index persistence (Index Checkpoint) are independent processes. They coordinate only at the final commit phase to update the SuperPage atomically.

### 7.1. Coordination Mechanism
*   **SuperPage Lock**: A lightweight mutex used only during the final, brief phase of swapping the `meta_page_id` in the SuperPage.
*   **Space Allocation**: All workflows pre-allocate pages from the SpaceMap to minimize contention.

### 7.2. Checkpoint Commit Phase (Generic)
All checkpoint workflows follow a similar commit protocol:

1.  **Acquire SuperPage Lock**.
2.  **Read current active MetaPage** (`ActiveMeta`).
3.  **Allocate a New MetaPage** (`NewMeta`).
4.  **Populate New MetaPage**:
    *   **Copy**: Copy all root pointers and watermarks from `ActiveMeta` to `NewMeta`.
    *   **Update**: Overwrite the specific fields managed by this checkpoint. For example:
        *   A **Data Checkpoint** updates `block_index_root`, `pivot_rowid`, and `watermarks.heap_redo_start_cts`.
        *   An **Index Checkpoint** updates `disktree_roots` and `watermarks.index_rec_cts`.
        *   A **Delta Checkpoint** updates `bitmap_tree_root` and `watermarks.delta_rec_cts`.
    *   **Set Timestamp**: Set `last_checkpoint_sts` to the `STS` of the system transaction coordinating the checkpoint.
    *   **GC Handling**: Add `ActiveMeta`'s Page ID and the checkpoint's locally accumulated garbage list (`local_gc_list`) to `NewMeta.gc_page_list`.
5.  **Persist New MetaPage**.
6.  **Atomic Anchor Update**: Update the **SuperPage** to point to `NewMeta`.
7.  **Release Lock**.

## 8. Summary

This design achieves:
1.  **Robustness**: The SuperPage protocol guarantees file integrity even during power failures.
2.  **Scalability**: Parallel checkpointing removes the single-threaded write bottleneck.
3.  **Non-Blocking Persistence**: Long transactions never block checkpoints.
5.  **HTAP Performance**: The LWC format with nullable support and random-access-friendly compression ensures the storage engine performs well for both transactional lookups and analytical scans.
