# Table File Design

## 1. Overview

The **Table File** is the fundamental physical persistence unit for a single table. It is designed to support **HTAP** workloads by combining efficient columnar scanning with fast random access for point lookups.

To ensure data consistency and recovery speed, the design strictly follows **Copy-on-Write (CoW)** and **Append-Only** principles. It integrates with the **No-Steal / No-Force** transactional model.

**Key Design Specifications:**
*   **Page Size:** Fixed at **64KB**.
*   **Indirection Architecture:** Separation of the **SuperPage** (Physical Anchor) and the **MetaPage** (Logical Snapshot) to allow non-blocking checkpoints.
*   **Atomicity:** Guaranteed via double-buffered SuperPages with Header-Footer validation.
*   **Decoupling:** Data Checkpoints (Tuple Mover) and Index Checkpoints operate independently.

## 2. Physical Layout

The file is divided into fixed-size 64KB pages. Page 0 is the fixed anchor; all other pages are dynamically allocated.

```text
+-------------------------------------------------------+
| Page 0: SuperPage (Double-Buffered Anchors A/B)       |
+-------------------------------------------------------+
| Page 1: MetaPage (Snapshot V100)                      | <--- Dynamic, CoW
+-------------------------------------------------------+
| Page 2: SpaceMap Page (Allocated/Free Bitmaps)        |
+-------------------------------------------------------+
| Page 3: LWC Data Block (RowID 0~N)                    |
+-------------------------------------------------------+
| Page 4: DiskTree Node (Index Internal/Leaf)           |
+-------------------------------------------------------+
| ...                                                   |
+-------------------------------------------------------+
| Page N: MetaPage (Snapshot V101)                      | <--- New version
+-------------------------------------------------------+
```

## 3. SuperPage Design (The Anchor)

The **SuperPage** (Page 0) acts as the static entry point to the file. It is lightweight and contains two slots for double-buffering. Each slot points to the latest valid **MetaPage**.

### 3.1. Structure of a Slot
| Section | Field | Description |
| :--- | :--- | :--- |
| **Header** | `magic_number` | File signature. |
| | `version` | File format version. |
| | `trx_id` | **Transaction ID** of the coordinator that wrote this slot. Used to identify the freshest anchor. |
| **Body** | **`meta_page_id`** | Pointer to the latest **MetaPage**. |
| **Footer** | `checksum` | CRC32C checksum of Header + Body. |
| | `trx_id_redundant` | Must match `Header.trx_id`. |

### 3.2. Atomic Update Protocol
To update the file state (commit a checkpoint):
1.  **Write**: Write Header (new `trx_id`), Body (new `meta_page_id`), and Footer to the inactive slot (A or B) within Page 0.
2.  **Fsync**: Persist Page 0 to disk.
3.  **Completion**: Once fsync returns successfully, the new state is valid. There is **no need** to check for active transactions during this step.

## 4. MetaPage Design (The Snapshot)

The **MetaPage** holds the complete state of the table at a specific point in time. It is a dynamic page managed via CoW. Every checkpoint creates a completely new MetaPage.

### 4.1. Structure
| Field | Description |
| :--- | :--- |
| `schema_info` | Column definitions, types, and compression metadata. |
| `block_index_root` | Root PageID of the **Block Index** (RowID -> LWC Block). |
| `disktree_roots` | Map `<IndexID, PageID>` storing roots for all Secondary Indexes. |
| `space_map_root` | PageID of the **SpaceMap**. |
| `pivot_rowid` | The watermark separating Disk Store (<) and Memory Store (>=). |
| **`last_checkpoint_sts`** | The logical watermark (Start Timestamp) of this snapshot. |
| **`gc_page_list`** | A list of PageIDs that became obsolete in this version (including the *previous* MetaPage ID). |

### 4.2. Lifecycle
*   **Creation**: Generated by the Coordinator at the end of a Data or Index Checkpoint.
*   **Obsolescence**: When a newer MetaPage is committed, the old MetaPage ID is added to the new MetaPage's `gc_page_list`.
*   **Reclamation**: When `MetaPage.last_checkpoint_cts` < `Global_Min_Active_STS`, the MetaPage **and** all pages in its `gc_page_list` are reclaimed.

## 5. Space Management & Garbage Collection

Space is managed via **SpaceMap Pages** (referenced by `MetaPage.space_map_root`).

### 5.1. Page States
1.  **Allocated**: In use by the current MetaPage or its children (Data, Index, Bitmaps).
2.  **GC_Wait**: Physically exists but logically obsolete. Referenced only by the `gc_page_list` of a MetaPage. Visible to long-running transactions holding that MetaPage.
3.  **Free**: Marked as free in the SpaceMap.

### 5.2. Non-Blocking GC Strategy
The Indirection Architecture solves the long transaction problem:

1.  **Scenario**: Transaction $T_{long}$ starts at logical time 100. It grabs the SuperPage, which points to `MetaPage_V1`.
2.  **Checkpoint**: A checkpoint runs at time 200. It creates `MetaPage_V2`.
    *   `MetaPage_V2.gc_page_list` includes `MetaPage_V1` and other old pages.
    *   SuperPage is updated to point to `MetaPage_V2`.
3.  **Result**:
    *   New transactions see `MetaPage_V2`.
    *   $T_{long}$ continues reading from `MetaPage_V1`.
    *   The background GC thread scans `MetaPage_V2`. It sees `MetaPage_V1` in the GC list. Since $T_{long}$ (Start Time 100) is still active, it **skips** recycling `MetaPage_V1`.
    *   Once $T_{long}$ commits, the next GC run will safely recycle `MetaPage_V1` and its children.

## 6. LWC Block Design (Data Storage)

LWC (LightWeight Columnar) blocks are stored in **PAX (Partition Attributes Across)** format within a 64KB page. They are optimized for both TP point lookups and AP scans.

### 6.1. Internal Structure

```text
[Block Header]
  - row_count
  - null_bitmap_offset
  - data_offsets[] (Start offset for each column)

[Null Bitmaps Area]
  - Column 1 NullBitmap (if nullable)
  - Column 2 NullBitmap ...
  - (Non-null columns occupy 0 bytes here)

[Data Area - Column 1]
  - Compression Metadata (Min/Max, Dict Base)
  - Payload (Compressed Data)

[Data Area - Column 2]
  ...
```

### 6.2. Compression Strategy

Algorithms are selected to ensure **O(1) random access** (or near O(1)) to support HTAP point queries without full block decompression.

1.  **Integers / Dates / Timestamps**:
    *   **Bitpacking (Frame of Reference)**: Store the `Min` value in metadata. Store deltas using the minimal number of bits required.
2.  **Strings (Low Cardinality)**:
    *   **Dictionary Encoding**: Store a local or global dictionary. Data payload consists of bitpacked integer IDs.
3.  **Strings (High Cardinality)**:
    *   **FSST (Fast Static Symbol Table)**: Allows random access to compressed strings and partial matching without full decompression.
4.  **Others (Default)**:
    *   **Flat**: Uncompressed storage to guarantee write/read performance.

## 7. Decoupled Checkpoint Workflows

Data persistence and Index persistence are independent processes. They coordinate only at the final step to update the SuperPage.

### 7.1. Coordination Mechanism
*   **SuperPage Lock**: A lightweight mutex used only when swapping the `meta_page_id` in the SuperPage.
*   **Space Allocation**: Both workflows pre-allocate pages from the SpaceMap to minimize contention.

### 7.2. Workflow A: Data Checkpoint (Tuple Mover)
*Trigger: Heap memory size / RowID growth.*

1.  **Write Phase**:
    *   Flush RowPages to new **LWC Blocks**.
    *   Merge `ColumnDeltaBuffer` into new **Bitmap Pages** (CoW).
    *   Update **Block Index** (CoW) -> Generates `New_BlockIndex_Root`.
    *   *Accumulate `local_gc_list` (Old Bitmap Pages, Old BlockIndex Nodes).*
2.  **Commit Phase**:
    *   Acquire **SuperPage Lock**.
    *   Read current active **MetaPage** (Active).
    *   Allocate a **New MetaPage**.
    *   Populate New MetaPage:
        *   Copy `disktree_roots`, `schema` from Active MetaPage.
        *   Set `block_index_root` = `New_BlockIndex_Root`.
        *   Set `pivot_rowid` = New Pivot.
        *   **GC Handling**: Add `Active MetaPage ID` and `local_gc_list` to `New MetaPage.gc_page_list`.
    *   Persist New MetaPage.
    *   **Atomic Anchor Update**: Update **SuperPage** to point to New MetaPage.
    *   Release Lock.

### 7.3. Workflow B: Index Checkpoint
*Trigger: MemTree memory usage.*

1.  **Dispatch Phase**:
    *   Freeze MemTree. Coordinator dispatches tasks to Workers.
2.  **Worker Phase**:
    *   Workers merge MemTree ranges into **DiskTrees** (CoW).
    *   Workers return `New_DiskTree_Roots` and `local_gc_list`.
3.  **Commit Phase**:
    *   Acquire **SuperPage Lock**.
    *   Read current active **MetaPage** (Active).
    *   Allocate a **New MetaPage**.
    *   Populate New MetaPage:
        *   Copy `block_index_root`, `pivot`, `schema` from Active MetaPage.
        *   Update `disktree_roots` with `New_DiskTree_Roots`.
        *   **GC Handling**: Add `Active MetaPage ID` and aggregated `local_gc_lists` to `New MetaPage.gc_page_list`.
    *   Persist New MetaPage.
    *   **Atomic Anchor Update**: Update **SuperPage** to point to New MetaPage.
    *   Release Lock.

## 8. Summary

This design achieves:
1.  **Robustness**: The SuperPage protocol guarantees file integrity even during power failures.
2.  **Scalability**: Parallel checkpointing removes the single-threaded write bottleneck.
3.  **Non-Blocking Persistence**: Long transactions never block checkpoints.
5.  **HTAP Performance**: The LWC format with nullable support and random-access-friendly compression ensures the storage engine performs well for both transactional lookups and analytical scans.
