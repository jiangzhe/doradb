use crate::error::{Error, Result};
use crate::lgc::op::{Op, OpKind};
use crate::lgc::ProjCol;
use doradb_expr::{QueryID, Setq};
use std::ops::{Deref, DerefMut};

#[derive(Debug, Clone)]
pub struct Setop {
    pub kind: SetopKind,
    pub q: Setq,
    /// Sources of Setop are always subqueries.
    pub left: SubqOp,
    pub right: SubqOp,
    pub cols: Vec<ProjCol>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SetopKind {
    Union,
    Except,
    Intersect,
}

impl SetopKind {
    #[inline]
    pub fn to_lower(&self) -> &'static str {
        match self {
            SetopKind::Union => "union",
            SetopKind::Except => "except",
            SetopKind::Intersect => "intersect",
        }
    }
}

/// SubqOp is subset of Op, which only includes
/// Query and Empty as its variants.
/// Empty is not naturally supported by SQL but can be
/// generated by optimizer.
#[derive(Debug, Clone, Default)]
pub struct SubqOp(Op);

impl SubqOp {
    // create a new subquery operator.
    #[inline]
    pub fn query(qry_id: QueryID) -> Self {
        SubqOp(Op::new(OpKind::Query(qry_id)))
    }
}

impl From<SubqOp> for Op {
    #[inline]
    fn from(src: SubqOp) -> Self {
        src.0
    }
}

impl TryFrom<Op> for SubqOp {
    type Error = Error;
    #[inline]
    fn try_from(src: Op) -> Result<Self> {
        match &src.kind {
            OpKind::Query(_) | OpKind::Empty => Ok(SubqOp(src)),
            _ => Err(Error::InvalidOpertorTransformation),
        }
    }
}

impl AsRef<Op> for SubqOp {
    #[inline]
    fn as_ref(&self) -> &Op {
        &self.0
    }
}

impl AsMut<Op> for SubqOp {
    #[inline]
    fn as_mut(&mut self) -> &mut Op {
        &mut self.0
    }
}

impl Deref for SubqOp {
    type Target = Op;
    #[inline]
    fn deref(&self) -> &Op {
        &self.0
    }
}

impl DerefMut for SubqOp {
    #[inline]
    fn deref_mut(&mut self) -> &mut Op {
        &mut self.0
    }
}
