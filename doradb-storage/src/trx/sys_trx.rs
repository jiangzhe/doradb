use crate::buffer::page::PageID;
use crate::buffer::BufferPool;
use crate::row::RowID;
use crate::serde::{LenPrefixPod, SerdeCtx};
use crate::trx::redo::{DDLRedo, RedoHeader, RedoLogs, RedoTrxKind};
use crate::trx::PreparedTrx;
use doradb_catalog::TableID;
use std::mem;

/// SysTrx is a special kind of transaction only used for system
/// operations. Its effect is immediately visible for other
/// transactions and it can not rollback.
pub struct SysTrx {
    pub(crate) redo: RedoLogs,
}

impl SysTrx {
    #[inline]
    pub fn create_row_page(
        &mut self,
        table_id: TableID,
        page_id: PageID,
        start_row_id: RowID,
        end_row_id: RowID,
    ) {
        // Actual row page is generated by block index and buffer pool.
        // Here we record page info in logging system for recovery.
        self.redo.ddl.push(DDLRedo::CreateRowPage {
            table_id,
            page_id,
            start_row_id,
            end_row_id,
        })
    }

    /// Prepare this transaction for commit.
    #[inline]
    pub fn prepare<P: BufferPool>(mut self) -> PreparedTrx<P> {
        let redo_bin = if self.redo.is_empty() {
            None
        } else {
            Some(LenPrefixPod::new(
                RedoHeader {
                    cts: 0,
                    trx_kind: RedoTrxKind::System,
                },
                mem::take(&mut self.redo),
                &SerdeCtx::default(),
            ))
        };
        PreparedTrx {
            redo_bin,
            payload: None,
            session: None,
        }
    }
}
