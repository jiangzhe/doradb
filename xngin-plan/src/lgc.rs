use crate::op::{Op, OpKind, OpVisitor};
use crate::query::{QuerySet, Subquery};
use xngin_expr::controlflow::ControlFlow;
use xngin_expr::QueryID;

/// LgcPlan represents a self-contained logical plan with
/// complete information about all its nodes.
pub struct LgcPlan {
    pub qry_set: QuerySet,
    pub root: QueryID,
    /// Original plan contains standalone queries
    /// that can be executed separately.
    /// Such queries are gathered and should be
    /// executed in parallel.
    pub attaches: Vec<QueryID>,
}

impl LgcPlan {
    /// Returns the shape of the query plan.
    /// The shape is presented by a sequence of Operators
    /// generated by preorder traversal on current plan.
    /// For example, The plan of "SELECT c0 FROM t1 JOIN t2"
    /// is represented as "[Proj, Join, Proj, Scan, Proj, Scan]"
    #[inline]
    pub fn shape(&self) -> Vec<OpKind> {
        let mut shape = vec![];
        generate_shape(&self.qry_set, &self.root, &mut shape);
        shape
    }

    #[inline]
    pub fn root_query(&self) -> Option<&Subquery> {
        self.qry_set.get(&self.root)
    }
}

fn generate_shape(qs: &QuerySet, root: &QueryID, shape: &mut Vec<OpKind>) {
    if let Some(subq) = qs.get(root) {
        let mut sg = ShapeGen { qs, shape };
        subq.root.walk(&mut sg);
    }
}

struct ShapeGen<'a> {
    qs: &'a QuerySet,
    shape: &'a mut Vec<OpKind>,
}

impl OpVisitor for ShapeGen<'_> {
    type Cont = ();
    type Break = ();
    #[inline]
    fn enter(&mut self, op: &Op) -> ControlFlow<()> {
        if let Op::Query(query_id) = op {
            generate_shape(self.qs, query_id, self.shape);
        } else {
            self.shape.push(op.kind());
        }
        ControlFlow::Continue(())
    }
}
